// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: station.proto
#ifndef GRPC_station_2eproto__INCLUDED
#define GRPC_station_2eproto__INCLUDED

#include "station.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

class MainStation final {
 public:
  static constexpr char const* service_full_name() {
    return "MainStation";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Passed(::grpc::ClientContext* context, const ::PassedRequest& request, ::None* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> AsyncPassed(::grpc::ClientContext* context, const ::PassedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(AsyncPassedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> PrepareAsyncPassed(::grpc::ClientContext* context, const ::PassedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(PrepareAsyncPassedRaw(context, request, cq));
    }
    virtual ::grpc::Status NoMoney(::grpc::ClientContext* context, const ::NoMoneyRequest& request, ::None* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> AsyncNoMoney(::grpc::ClientContext* context, const ::NoMoneyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(AsyncNoMoneyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> PrepareAsyncNoMoney(::grpc::ClientContext* context, const ::NoMoneyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(PrepareAsyncNoMoneyRaw(context, request, cq));
    }
    virtual ::grpc::Status GetOil(::grpc::ClientContext* context, const ::GetOilRequest& request, ::None* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> AsyncGetOil(::grpc::ClientContext* context, const ::GetOilRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(AsyncGetOilRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> PrepareAsyncGetOil(::grpc::ClientContext* context, const ::GetOilRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(PrepareAsyncGetOilRaw(context, request, cq));
    }
    virtual ::grpc::Status Fail(::grpc::ClientContext* context, const ::FailRequest& request, ::None* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> AsyncFail(::grpc::ClientContext* context, const ::FailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(AsyncFailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> PrepareAsyncFail(::grpc::ClientContext* context, const ::FailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(PrepareAsyncFailRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Passed(::grpc::ClientContext* context, const ::PassedRequest* request, ::None* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Passed(::grpc::ClientContext* context, const ::PassedRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void NoMoney(::grpc::ClientContext* context, const ::NoMoneyRequest* request, ::None* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NoMoney(::grpc::ClientContext* context, const ::NoMoneyRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetOil(::grpc::ClientContext* context, const ::GetOilRequest* request, ::None* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetOil(::grpc::ClientContext* context, const ::GetOilRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Fail(::grpc::ClientContext* context, const ::FailRequest* request, ::None* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Fail(::grpc::ClientContext* context, const ::FailRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* AsyncPassedRaw(::grpc::ClientContext* context, const ::PassedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* PrepareAsyncPassedRaw(::grpc::ClientContext* context, const ::PassedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* AsyncNoMoneyRaw(::grpc::ClientContext* context, const ::NoMoneyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* PrepareAsyncNoMoneyRaw(::grpc::ClientContext* context, const ::NoMoneyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* AsyncGetOilRaw(::grpc::ClientContext* context, const ::GetOilRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* PrepareAsyncGetOilRaw(::grpc::ClientContext* context, const ::GetOilRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* AsyncFailRaw(::grpc::ClientContext* context, const ::FailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* PrepareAsyncFailRaw(::grpc::ClientContext* context, const ::FailRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Passed(::grpc::ClientContext* context, const ::PassedRequest& request, ::None* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> AsyncPassed(::grpc::ClientContext* context, const ::PassedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(AsyncPassedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> PrepareAsyncPassed(::grpc::ClientContext* context, const ::PassedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(PrepareAsyncPassedRaw(context, request, cq));
    }
    ::grpc::Status NoMoney(::grpc::ClientContext* context, const ::NoMoneyRequest& request, ::None* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> AsyncNoMoney(::grpc::ClientContext* context, const ::NoMoneyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(AsyncNoMoneyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> PrepareAsyncNoMoney(::grpc::ClientContext* context, const ::NoMoneyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(PrepareAsyncNoMoneyRaw(context, request, cq));
    }
    ::grpc::Status GetOil(::grpc::ClientContext* context, const ::GetOilRequest& request, ::None* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> AsyncGetOil(::grpc::ClientContext* context, const ::GetOilRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(AsyncGetOilRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> PrepareAsyncGetOil(::grpc::ClientContext* context, const ::GetOilRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(PrepareAsyncGetOilRaw(context, request, cq));
    }
    ::grpc::Status Fail(::grpc::ClientContext* context, const ::FailRequest& request, ::None* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> AsyncFail(::grpc::ClientContext* context, const ::FailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(AsyncFailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> PrepareAsyncFail(::grpc::ClientContext* context, const ::FailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(PrepareAsyncFailRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Passed(::grpc::ClientContext* context, const ::PassedRequest* request, ::None* response, std::function<void(::grpc::Status)>) override;
      void Passed(::grpc::ClientContext* context, const ::PassedRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) override;
      void NoMoney(::grpc::ClientContext* context, const ::NoMoneyRequest* request, ::None* response, std::function<void(::grpc::Status)>) override;
      void NoMoney(::grpc::ClientContext* context, const ::NoMoneyRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetOil(::grpc::ClientContext* context, const ::GetOilRequest* request, ::None* response, std::function<void(::grpc::Status)>) override;
      void GetOil(::grpc::ClientContext* context, const ::GetOilRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Fail(::grpc::ClientContext* context, const ::FailRequest* request, ::None* response, std::function<void(::grpc::Status)>) override;
      void Fail(::grpc::ClientContext* context, const ::FailRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::None>* AsyncPassedRaw(::grpc::ClientContext* context, const ::PassedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* PrepareAsyncPassedRaw(::grpc::ClientContext* context, const ::PassedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* AsyncNoMoneyRaw(::grpc::ClientContext* context, const ::NoMoneyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* PrepareAsyncNoMoneyRaw(::grpc::ClientContext* context, const ::NoMoneyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* AsyncGetOilRaw(::grpc::ClientContext* context, const ::GetOilRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* PrepareAsyncGetOilRaw(::grpc::ClientContext* context, const ::GetOilRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* AsyncFailRaw(::grpc::ClientContext* context, const ::FailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* PrepareAsyncFailRaw(::grpc::ClientContext* context, const ::FailRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Passed_;
    const ::grpc::internal::RpcMethod rpcmethod_NoMoney_;
    const ::grpc::internal::RpcMethod rpcmethod_GetOil_;
    const ::grpc::internal::RpcMethod rpcmethod_Fail_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Passed(::grpc::ServerContext* context, const ::PassedRequest* request, ::None* response);
    virtual ::grpc::Status NoMoney(::grpc::ServerContext* context, const ::NoMoneyRequest* request, ::None* response);
    virtual ::grpc::Status GetOil(::grpc::ServerContext* context, const ::GetOilRequest* request, ::None* response);
    virtual ::grpc::Status Fail(::grpc::ServerContext* context, const ::FailRequest* request, ::None* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Passed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Passed() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Passed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Passed(::grpc::ServerContext* /*context*/, const ::PassedRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPassed(::grpc::ServerContext* context, ::PassedRequest* request, ::grpc::ServerAsyncResponseWriter< ::None>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NoMoney : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NoMoney() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_NoMoney() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NoMoney(::grpc::ServerContext* /*context*/, const ::NoMoneyRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNoMoney(::grpc::ServerContext* context, ::NoMoneyRequest* request, ::grpc::ServerAsyncResponseWriter< ::None>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOil : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetOil() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetOil() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOil(::grpc::ServerContext* /*context*/, const ::GetOilRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOil(::grpc::ServerContext* context, ::GetOilRequest* request, ::grpc::ServerAsyncResponseWriter< ::None>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Fail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Fail() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Fail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fail(::grpc::ServerContext* /*context*/, const ::FailRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFail(::grpc::ServerContext* context, ::FailRequest* request, ::grpc::ServerAsyncResponseWriter< ::None>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Passed<WithAsyncMethod_NoMoney<WithAsyncMethod_GetOil<WithAsyncMethod_Fail<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Passed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Passed() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::PassedRequest, ::None>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::PassedRequest* request, ::None* response) { return this->Passed(context, request, response); }));}
    void SetMessageAllocatorFor_Passed(
        ::grpc::MessageAllocator< ::PassedRequest, ::None>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::PassedRequest, ::None>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Passed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Passed(::grpc::ServerContext* /*context*/, const ::PassedRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Passed(
      ::grpc::CallbackServerContext* /*context*/, const ::PassedRequest* /*request*/, ::None* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_NoMoney : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_NoMoney() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::NoMoneyRequest, ::None>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::NoMoneyRequest* request, ::None* response) { return this->NoMoney(context, request, response); }));}
    void SetMessageAllocatorFor_NoMoney(
        ::grpc::MessageAllocator< ::NoMoneyRequest, ::None>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::NoMoneyRequest, ::None>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_NoMoney() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NoMoney(::grpc::ServerContext* /*context*/, const ::NoMoneyRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NoMoney(
      ::grpc::CallbackServerContext* /*context*/, const ::NoMoneyRequest* /*request*/, ::None* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetOil : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetOil() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::GetOilRequest, ::None>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::GetOilRequest* request, ::None* response) { return this->GetOil(context, request, response); }));}
    void SetMessageAllocatorFor_GetOil(
        ::grpc::MessageAllocator< ::GetOilRequest, ::None>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::GetOilRequest, ::None>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetOil() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOil(::grpc::ServerContext* /*context*/, const ::GetOilRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOil(
      ::grpc::CallbackServerContext* /*context*/, const ::GetOilRequest* /*request*/, ::None* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Fail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Fail() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::FailRequest, ::None>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::FailRequest* request, ::None* response) { return this->Fail(context, request, response); }));}
    void SetMessageAllocatorFor_Fail(
        ::grpc::MessageAllocator< ::FailRequest, ::None>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::FailRequest, ::None>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Fail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fail(::grpc::ServerContext* /*context*/, const ::FailRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Fail(
      ::grpc::CallbackServerContext* /*context*/, const ::FailRequest* /*request*/, ::None* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Passed<WithCallbackMethod_NoMoney<WithCallbackMethod_GetOil<WithCallbackMethod_Fail<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Passed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Passed() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Passed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Passed(::grpc::ServerContext* /*context*/, const ::PassedRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NoMoney : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NoMoney() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_NoMoney() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NoMoney(::grpc::ServerContext* /*context*/, const ::NoMoneyRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetOil : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetOil() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetOil() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOil(::grpc::ServerContext* /*context*/, const ::GetOilRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Fail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Fail() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Fail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fail(::grpc::ServerContext* /*context*/, const ::FailRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Passed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Passed() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Passed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Passed(::grpc::ServerContext* /*context*/, const ::PassedRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPassed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NoMoney : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NoMoney() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_NoMoney() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NoMoney(::grpc::ServerContext* /*context*/, const ::NoMoneyRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNoMoney(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOil : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetOil() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetOil() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOil(::grpc::ServerContext* /*context*/, const ::GetOilRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOil(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Fail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Fail() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Fail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fail(::grpc::ServerContext* /*context*/, const ::FailRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFail(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Passed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Passed() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Passed(context, request, response); }));
    }
    ~WithRawCallbackMethod_Passed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Passed(::grpc::ServerContext* /*context*/, const ::PassedRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Passed(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_NoMoney : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_NoMoney() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NoMoney(context, request, response); }));
    }
    ~WithRawCallbackMethod_NoMoney() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NoMoney(::grpc::ServerContext* /*context*/, const ::NoMoneyRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NoMoney(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetOil : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetOil() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetOil(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetOil() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOil(::grpc::ServerContext* /*context*/, const ::GetOilRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOil(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Fail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Fail() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Fail(context, request, response); }));
    }
    ~WithRawCallbackMethod_Fail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fail(::grpc::ServerContext* /*context*/, const ::FailRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Fail(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Passed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Passed() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::PassedRequest, ::None>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::PassedRequest, ::None>* streamer) {
                       return this->StreamedPassed(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Passed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Passed(::grpc::ServerContext* /*context*/, const ::PassedRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPassed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::PassedRequest,::None>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NoMoney : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NoMoney() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::NoMoneyRequest, ::None>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::NoMoneyRequest, ::None>* streamer) {
                       return this->StreamedNoMoney(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NoMoney() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NoMoney(::grpc::ServerContext* /*context*/, const ::NoMoneyRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNoMoney(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::NoMoneyRequest,::None>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetOil : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetOil() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::GetOilRequest, ::None>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::GetOilRequest, ::None>* streamer) {
                       return this->StreamedGetOil(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetOil() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOil(::grpc::ServerContext* /*context*/, const ::GetOilRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetOil(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GetOilRequest,::None>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Fail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Fail() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::FailRequest, ::None>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::FailRequest, ::None>* streamer) {
                       return this->StreamedFail(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Fail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Fail(::grpc::ServerContext* /*context*/, const ::FailRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFail(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::FailRequest,::None>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Passed<WithStreamedUnaryMethod_NoMoney<WithStreamedUnaryMethod_GetOil<WithStreamedUnaryMethod_Fail<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Passed<WithStreamedUnaryMethod_NoMoney<WithStreamedUnaryMethod_GetOil<WithStreamedUnaryMethod_Fail<Service > > > > StreamedService;
};

class Station final {
 public:
  static constexpr char const* service_full_name() {
    return "Station";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Init(::grpc::ClientContext* context, const ::InitRequest& request, ::None* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> AsyncInit(::grpc::ClientContext* context, const ::InitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(AsyncInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> PrepareAsyncInit(::grpc::ClientContext* context, const ::InitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(PrepareAsyncInitRaw(context, request, cq));
    }
    virtual ::grpc::Status Link(::grpc::ClientContext* context, const ::LinkRequest& request, ::None* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> AsyncLink(::grpc::ClientContext* context, const ::LinkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(AsyncLinkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> PrepareAsyncLink(::grpc::ClientContext* context, const ::LinkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(PrepareAsyncLinkRaw(context, request, cq));
    }
    virtual ::grpc::Status SendOil(::grpc::ClientContext* context, const ::SendOilRequest& request, ::None* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> AsyncSendOil(::grpc::ClientContext* context, const ::SendOilRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(AsyncSendOilRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> PrepareAsyncSendOil(::grpc::ClientContext* context, const ::SendOilRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(PrepareAsyncSendOilRaw(context, request, cq));
    }
    virtual ::grpc::Status AddMoney(::grpc::ClientContext* context, const ::AddMoneyRequest& request, ::None* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> AsyncAddMoney(::grpc::ClientContext* context, const ::AddMoneyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(AsyncAddMoneyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>> PrepareAsyncAddMoney(::grpc::ClientContext* context, const ::AddMoneyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::None>>(PrepareAsyncAddMoneyRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Init(::grpc::ClientContext* context, const ::InitRequest* request, ::None* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Init(::grpc::ClientContext* context, const ::InitRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Link(::grpc::ClientContext* context, const ::LinkRequest* request, ::None* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Link(::grpc::ClientContext* context, const ::LinkRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SendOil(::grpc::ClientContext* context, const ::SendOilRequest* request, ::None* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendOil(::grpc::ClientContext* context, const ::SendOilRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void AddMoney(::grpc::ClientContext* context, const ::AddMoneyRequest* request, ::None* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddMoney(::grpc::ClientContext* context, const ::AddMoneyRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* AsyncInitRaw(::grpc::ClientContext* context, const ::InitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* PrepareAsyncInitRaw(::grpc::ClientContext* context, const ::InitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* AsyncLinkRaw(::grpc::ClientContext* context, const ::LinkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* PrepareAsyncLinkRaw(::grpc::ClientContext* context, const ::LinkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* AsyncSendOilRaw(::grpc::ClientContext* context, const ::SendOilRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* PrepareAsyncSendOilRaw(::grpc::ClientContext* context, const ::SendOilRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* AsyncAddMoneyRaw(::grpc::ClientContext* context, const ::AddMoneyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::None>* PrepareAsyncAddMoneyRaw(::grpc::ClientContext* context, const ::AddMoneyRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Init(::grpc::ClientContext* context, const ::InitRequest& request, ::None* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> AsyncInit(::grpc::ClientContext* context, const ::InitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(AsyncInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> PrepareAsyncInit(::grpc::ClientContext* context, const ::InitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(PrepareAsyncInitRaw(context, request, cq));
    }
    ::grpc::Status Link(::grpc::ClientContext* context, const ::LinkRequest& request, ::None* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> AsyncLink(::grpc::ClientContext* context, const ::LinkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(AsyncLinkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> PrepareAsyncLink(::grpc::ClientContext* context, const ::LinkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(PrepareAsyncLinkRaw(context, request, cq));
    }
    ::grpc::Status SendOil(::grpc::ClientContext* context, const ::SendOilRequest& request, ::None* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> AsyncSendOil(::grpc::ClientContext* context, const ::SendOilRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(AsyncSendOilRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> PrepareAsyncSendOil(::grpc::ClientContext* context, const ::SendOilRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(PrepareAsyncSendOilRaw(context, request, cq));
    }
    ::grpc::Status AddMoney(::grpc::ClientContext* context, const ::AddMoneyRequest& request, ::None* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> AsyncAddMoney(::grpc::ClientContext* context, const ::AddMoneyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(AsyncAddMoneyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>> PrepareAsyncAddMoney(::grpc::ClientContext* context, const ::AddMoneyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::None>>(PrepareAsyncAddMoneyRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Init(::grpc::ClientContext* context, const ::InitRequest* request, ::None* response, std::function<void(::grpc::Status)>) override;
      void Init(::grpc::ClientContext* context, const ::InitRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Link(::grpc::ClientContext* context, const ::LinkRequest* request, ::None* response, std::function<void(::grpc::Status)>) override;
      void Link(::grpc::ClientContext* context, const ::LinkRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SendOil(::grpc::ClientContext* context, const ::SendOilRequest* request, ::None* response, std::function<void(::grpc::Status)>) override;
      void SendOil(::grpc::ClientContext* context, const ::SendOilRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AddMoney(::grpc::ClientContext* context, const ::AddMoneyRequest* request, ::None* response, std::function<void(::grpc::Status)>) override;
      void AddMoney(::grpc::ClientContext* context, const ::AddMoneyRequest* request, ::None* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::None>* AsyncInitRaw(::grpc::ClientContext* context, const ::InitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* PrepareAsyncInitRaw(::grpc::ClientContext* context, const ::InitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* AsyncLinkRaw(::grpc::ClientContext* context, const ::LinkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* PrepareAsyncLinkRaw(::grpc::ClientContext* context, const ::LinkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* AsyncSendOilRaw(::grpc::ClientContext* context, const ::SendOilRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* PrepareAsyncSendOilRaw(::grpc::ClientContext* context, const ::SendOilRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* AsyncAddMoneyRaw(::grpc::ClientContext* context, const ::AddMoneyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::None>* PrepareAsyncAddMoneyRaw(::grpc::ClientContext* context, const ::AddMoneyRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Init_;
    const ::grpc::internal::RpcMethod rpcmethod_Link_;
    const ::grpc::internal::RpcMethod rpcmethod_SendOil_;
    const ::grpc::internal::RpcMethod rpcmethod_AddMoney_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Init(::grpc::ServerContext* context, const ::InitRequest* request, ::None* response);
    virtual ::grpc::Status Link(::grpc::ServerContext* context, const ::LinkRequest* request, ::None* response);
    virtual ::grpc::Status SendOil(::grpc::ServerContext* context, const ::SendOilRequest* request, ::None* response);
    virtual ::grpc::Status AddMoney(::grpc::ServerContext* context, const ::AddMoneyRequest* request, ::None* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Init : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Init() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Init() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Init(::grpc::ServerContext* /*context*/, const ::InitRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInit(::grpc::ServerContext* context, ::InitRequest* request, ::grpc::ServerAsyncResponseWriter< ::None>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Link : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Link() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Link() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Link(::grpc::ServerContext* /*context*/, const ::LinkRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLink(::grpc::ServerContext* context, ::LinkRequest* request, ::grpc::ServerAsyncResponseWriter< ::None>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendOil : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendOil() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SendOil() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendOil(::grpc::ServerContext* /*context*/, const ::SendOilRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendOil(::grpc::ServerContext* context, ::SendOilRequest* request, ::grpc::ServerAsyncResponseWriter< ::None>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddMoney : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddMoney() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_AddMoney() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddMoney(::grpc::ServerContext* /*context*/, const ::AddMoneyRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddMoney(::grpc::ServerContext* context, ::AddMoneyRequest* request, ::grpc::ServerAsyncResponseWriter< ::None>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Init<WithAsyncMethod_Link<WithAsyncMethod_SendOil<WithAsyncMethod_AddMoney<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Init : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Init() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::InitRequest, ::None>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::InitRequest* request, ::None* response) { return this->Init(context, request, response); }));}
    void SetMessageAllocatorFor_Init(
        ::grpc::MessageAllocator< ::InitRequest, ::None>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::InitRequest, ::None>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Init() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Init(::grpc::ServerContext* /*context*/, const ::InitRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Init(
      ::grpc::CallbackServerContext* /*context*/, const ::InitRequest* /*request*/, ::None* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Link : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Link() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::LinkRequest, ::None>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::LinkRequest* request, ::None* response) { return this->Link(context, request, response); }));}
    void SetMessageAllocatorFor_Link(
        ::grpc::MessageAllocator< ::LinkRequest, ::None>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::LinkRequest, ::None>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Link() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Link(::grpc::ServerContext* /*context*/, const ::LinkRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Link(
      ::grpc::CallbackServerContext* /*context*/, const ::LinkRequest* /*request*/, ::None* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SendOil : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendOil() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::SendOilRequest, ::None>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::SendOilRequest* request, ::None* response) { return this->SendOil(context, request, response); }));}
    void SetMessageAllocatorFor_SendOil(
        ::grpc::MessageAllocator< ::SendOilRequest, ::None>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SendOilRequest, ::None>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendOil() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendOil(::grpc::ServerContext* /*context*/, const ::SendOilRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendOil(
      ::grpc::CallbackServerContext* /*context*/, const ::SendOilRequest* /*request*/, ::None* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddMoney : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AddMoney() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::AddMoneyRequest, ::None>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::AddMoneyRequest* request, ::None* response) { return this->AddMoney(context, request, response); }));}
    void SetMessageAllocatorFor_AddMoney(
        ::grpc::MessageAllocator< ::AddMoneyRequest, ::None>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::AddMoneyRequest, ::None>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddMoney() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddMoney(::grpc::ServerContext* /*context*/, const ::AddMoneyRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddMoney(
      ::grpc::CallbackServerContext* /*context*/, const ::AddMoneyRequest* /*request*/, ::None* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Init<WithCallbackMethod_Link<WithCallbackMethod_SendOil<WithCallbackMethod_AddMoney<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Init : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Init() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Init() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Init(::grpc::ServerContext* /*context*/, const ::InitRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Link : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Link() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Link() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Link(::grpc::ServerContext* /*context*/, const ::LinkRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendOil : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendOil() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SendOil() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendOil(::grpc::ServerContext* /*context*/, const ::SendOilRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddMoney : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddMoney() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_AddMoney() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddMoney(::grpc::ServerContext* /*context*/, const ::AddMoneyRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Init : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Init() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Init() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Init(::grpc::ServerContext* /*context*/, const ::InitRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Link : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Link() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Link() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Link(::grpc::ServerContext* /*context*/, const ::LinkRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLink(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendOil : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendOil() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SendOil() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendOil(::grpc::ServerContext* /*context*/, const ::SendOilRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendOil(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddMoney : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddMoney() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_AddMoney() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddMoney(::grpc::ServerContext* /*context*/, const ::AddMoneyRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddMoney(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Init : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Init() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Init(context, request, response); }));
    }
    ~WithRawCallbackMethod_Init() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Init(::grpc::ServerContext* /*context*/, const ::InitRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Init(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Link : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Link() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Link(context, request, response); }));
    }
    ~WithRawCallbackMethod_Link() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Link(::grpc::ServerContext* /*context*/, const ::LinkRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Link(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendOil : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendOil() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendOil(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendOil() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendOil(::grpc::ServerContext* /*context*/, const ::SendOilRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendOil(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddMoney : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AddMoney() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddMoney(context, request, response); }));
    }
    ~WithRawCallbackMethod_AddMoney() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddMoney(::grpc::ServerContext* /*context*/, const ::AddMoneyRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddMoney(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Init : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Init() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InitRequest, ::None>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::InitRequest, ::None>* streamer) {
                       return this->StreamedInit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Init() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Init(::grpc::ServerContext* /*context*/, const ::InitRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InitRequest,::None>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Link : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Link() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LinkRequest, ::None>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::LinkRequest, ::None>* streamer) {
                       return this->StreamedLink(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Link() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Link(::grpc::ServerContext* /*context*/, const ::LinkRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLink(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LinkRequest,::None>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendOil : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendOil() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SendOilRequest, ::None>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SendOilRequest, ::None>* streamer) {
                       return this->StreamedSendOil(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendOil() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendOil(::grpc::ServerContext* /*context*/, const ::SendOilRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendOil(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SendOilRequest,::None>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddMoney : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddMoney() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::AddMoneyRequest, ::None>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::AddMoneyRequest, ::None>* streamer) {
                       return this->StreamedAddMoney(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddMoney() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddMoney(::grpc::ServerContext* /*context*/, const ::AddMoneyRequest* /*request*/, ::None* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddMoney(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AddMoneyRequest,::None>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Init<WithStreamedUnaryMethod_Link<WithStreamedUnaryMethod_SendOil<WithStreamedUnaryMethod_AddMoney<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Init<WithStreamedUnaryMethod_Link<WithStreamedUnaryMethod_SendOil<WithStreamedUnaryMethod_AddMoney<Service > > > > StreamedService;
};


#endif  // GRPC_station_2eproto__INCLUDED
